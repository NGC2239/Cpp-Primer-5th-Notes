# 第二章  变量和基本类型



## 2.1  基本内置类型

### 2.1.1  算术类型

​	算术类型分为两类：**整型**（包括字符和布尔类型在内）和**浮点型**。

​	表2.1列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fkinvy-images.oss-cn-beijing.aliyuncs.com%2FImages%2Fimage-20220606100005905.png&sign=990eac26402d3b71ae064e2cac2fdccbe14b341265548cfc8fc9fa6efdddf8d3)

#### 带符号类型和无符号类型

​	除去布尔型和扩展的字符型之外，其他**整型**可以划分为 **带符号的** 和 **无符号的 **两种。

​	类型int、short、long和long long 都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型。



​	与其他整型不同，字符型被分为三种：char、signed char 和 unsigned char

​	**注意：**类型char和类型signed char并不同。类型char实际上表现为哪一种，由编译器决定。

##### **如何选择类型**

- 明确知晓数值不可能为负，则选用无符号类型
- 使用int执行整数运算。short常常显得太小而long一般和int有一样的尺寸。如果数值超过了int的表示范围，选用long long
- 在算数表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。 因为char在不同的机器上可能表现为不同的类型，如果需要使用一个不大的整数，明确其类型是signed char或者unsigned char。
- 执行浮点数运算选用double，float通常精度不够而且双精度浮点数和单精度浮点数计算代价相差无几。long double 提供的精度在一般情况下是没有必要的，况且运行时的消耗不容忽视。

### 2.1.2  类型转换

#### **关于取模(MOD)和取余(REM)**

取模和取余的差别就在于取整的方式，取余是向0的方向舍入，取模的时候向无穷小的方向舍入。

计算公式如下：

```
第一步：求整数商， c = a / b
第二步：计算模或余数， r = a - c * b
```

其中第二步是相同的，不同的是第一步中涉及到当a 和 b符号不同时的操作：两个都是正数时没有差别，当存在负数时舍入方向不同。

例如：计算-7 Mod 4

其中，a = -7， b = 4；

第一步：求整数商，取模运算 c = -2（向负无穷方向舍入）， 取余c = -1（向0方向舍入）

第二步：计算模或余数，取模时 r = 1， 取余 r = -3.

在不同的编程语言环境下" % "意义不同，C/C++中代表取余，而python中代表取模

了解该概念后就能很好的理解书中所说的

> ​	“***当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。**例如， 8比特大小的unsigned char 可以表示0 至 255 区间内的值，如果我么赋值给此类型变量一个区间以外的值，则实际的结果是该值对256取模后所得的余数。因此， 把 -1 赋值为8比特大小的unsigned char 所得的结果是255.*”

#### 含有无符号类型的表达式

​	当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号数：

```c++
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;   // 输出 -84
std::cout << u + i << std::endl;   // 如果 int 占 32bit，输出 4294967264
```

​	如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。

​	但需要注意的是，signed short int 与 unsigned short int 之间运算时，并没有转换：

```c++
unsigned short int a = 20;
signed  short int b = -130;
std::cout << a + b << endl;    //输出 -110
```

#### 2.1.3  字面值常量

​	指在程序中无需保存，可直接表示为一个具体的数字或字符串等其他的值，形如 42 这样的值被称为字面值常量（literal）；

​	每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。



## 2.2  变量

### 2.2.1 变量的定义

​	何为对象？ 通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。和 ‘变量’ 一般可以互换使用。

#### 初始值

​	当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。

​	**warning：** 初始化和赋值是两个完全不同的操作，在很多编程语言中二者的区别几乎可以忽略不计，即使在C++中有时也无关紧要，但仍需注意，初始化是在创建时赋予其一个初始值，赋值是把对象当前值擦除，以一个新值替代。

#### 列表初始化

​	C++定义了初始化的好几种不同的形式，想要定义一个int类型的变量，并且初始化为0，以下4条语句都可以实现：

```c++
int val = 0;
int val = {0};
int val{0};
int val(0);
```

​	作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用，这种形式被称为列表初始化（list initialization）。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用由花括号括起来的初始值了。

​	这种初始化有一个重要特点：如果使用列表初始化且初始值存在丢失信息的风险，编译器将报错：

```c++
long double pi = 3.1415926;
int a{pi};	          //错误：转换未执行，因为存在丢失信息的风险
int b(ld), d = ld;    //正确：转换执行，且丢失了部分值
```

​	值得注意的是，**列表初始化** 和 **初始化列表** 并不相同，初始化列表是构造函数的周边概念，表示在执行构造函数中，先执行初始化列表，再执行函数体内的语句。

#### 默认初始化

​	如果定义变量时没有指定初值，则变量被默认初始化，默认值由变量类型决定，定义变量的位置也会对此有影响。

- 定义于任何函数体之外的变量被初始化为0.

- 定义在函数体内部的局部变量和类中的成员属性是不会被初始化的，**一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将会引发错误。**
- 每个类各自决定其初始化对象的方式。如果没有显式地初始化，则其值由类确定。



### 2.2.2  变量声明和定义

​	C++语言支持**分离式编译**机制，允许将程序分割为若干个文件，每个文件可被独立编译

​	为了支持分离式编译，C++将声明和定义区分开来。

- 声明（declaration）：使得名字为程序所知；

- 定义（definition）：负责创建与名字关联的实体。

```c++
extern int i;	//声明i
extern int i = 1;	//错误，给i赋值extern失效
int j;		//声明并定义j
```

注意：变量能且只能被定义一次，但是可以被多次声明。

#### 静态类型

​	C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。

​	对象的类型决定了对象能参与的运算。在C++中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。

​	程序越复杂，静态类型检查越有助于发现问题。因此我们在使用某个变量前必须声明其类型，让编译器知道。

### 2.2.3  标识符

​	由字母、数字、下划线组成，必须以字母或下划线开头，长度没有限制，对大小写敏感。

​	对于：

> *”同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。“*

​	此段的描述，英文版原版中用的是may not，并且实际情况确实可以以这种方式命名，但正如书中所说是为了标准库保留的标识符格式，不应该这么做。

### 2.2.4  名字的作用域

​	**作用域**、**全局作用域**、**块作用域**



## 2.3  复合类型

​	基于其他类型定义的类型。

### 2.3.1  引用

​	**引用**（reference） 为变量（对象）起了另外一个名字，引用必须被初始化，因为引用是与初始值对象绑定在一起，而不是拷贝，且初值必须是一个对象，除了2.4.1节*（初始化常量引用时允许用任意表达式作为初始值，但结果要能转换成引用的类型）*和15.2.3节*（基类的引用绑定到派生类对象上）*这两种情况外，其他所有引用都要和与之绑定的对象严格匹配。

​	引用本身不是一个对象，所以不能定义引用的引用。

```c++
int i = 1024, i2 = 2048; 	// i和i2都是 int
int &r = i; r2 = i2;		// r是一个引用， 与i绑定在一起，r2是int
int i3 = 1024, &ri = i3;	// i3 是int，ri是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;		// r3和r4都是引用

// 类型必须一致
int &refVal3;           // 错误： 引用必须初始化
int &refVal4 = 10;		// 错误： 引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;	// 错误：此处引用类型的初始值必须是 int 型对象
```

​	C++11中新增了一种 ”右值引用“ 这种引用主要用于内置类，当我们使用术语 ”引用“时，指的是”左值引用“。

### 2.3.2  指针

​	**指针** 是 “指向（point to）” 另外一种类型的复合类型。

​	指针和引用的不同。其一，指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内可以先后指向几个不同的对象；其二，指针无须在定义时赋初值。在块作用域内定义的指针若没有被初始化，将拥有一个不确定的值。

#### 获取对象的地址

​	指针存放某个对象的地址，要想获取该地址，需要使用 **取地址符**（操作符&）：

```c++
int ival = 42;
int *p = &ival;		// p 存放变量ival的地址，或者说p是指向变量ival的指针
```

​	引用不是对象，没有实际地址，所以不能定义指向引用的指针。

​	除了2.4.2节*（指向常量的指针(pointer to const) 可以指向一个非常量对象）*和 15.2.3节*（基类的指针可以指向派生类的对象）*中提到的这两种情况外，其他所有指针的类型都要和它所指向的对象严格匹配。

#### 指针值

指针值（即地址）应属于下列4种状态之一：

1. 指向一个对象
2. 指紧邻对象所占空间的下一个位置
3. 空指针，意味着指针没有指向任何对象
4. 无效指针，也就是上述情况之外的其他值

**注意：**不要访问无效指针，同样的第2、3种虽然有效但并没有指向具体的对象，因此不能访问此类指针的对象。

#### 利用指针访问对象

如果指针指向一个对象，则允许使用 **解引用符** （操作符`*` ）来访问对象

解引用操作仅适用与那些确实指向了某个对象的有效指针。

#### 空指针

不指向任何对象，以下为生成空指针的方法：

```c++
int *p1 = nullptr;		// 等价于 int *p1 = 0;
int *p2 = 0;			// 直接将 p2初始化为字面常量0
// 需要首先 #include <cstdlib>
int *p3 = NULL;			// 等价于 int *p3 = 0;
```

最直接的办法是使用字面值`nullptr`来初始化，它可以转换成任意其他的指针类型。或通过p2的方式，利用字面值0，在新标准下，要尽量避免使用p3，NULL是预处理变量，初始化方式和p2其实相同。

**注意**：不能用int变量直接赋值，即使变量值为0。并且应尽量初始化所有指针。

#### 赋值和指针

​	有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值，最好的办法是记住赋值永远改变的是等号左侧的对象

```c++
pi = &ival;       //pi的值被改变，现在pi指向ival
*pi = 0;          //ival的值被改变，指针pi并没有改变
```

#### 其他指针操作

​	只要指针拥有一个合法值，就能将它用在条件表达式中。如果指针的值是 0， 条件取 `false`，任何非0的指针对应的条件值都是 `true`

​	对于两个类型相同的合法指针，还可以用相等操作符 （`==`）或不相等操作符 （`!=`）来比较它们，比较的结果是布尔类型。比较的是两个指针存放的地址。

#### void* 指针

指针就是一个整数，没有实际的数值大小，只是一个编号，这个编号指向的是内存中的某个地址。指针无论定义成什么基本类型，其值都是一个固定位数的整数，指针类型数据的大小取决于系统的位数，32bit的系统指针变量大小是4byte = 32 bit, 64 bit系统指针是 8 byte = 64bit。

**但是，编译器为了兼容，指针都是4个字节长度**

`void*` 是一种特殊的指针类型，可用于存放任意对象的地址。它所存放的地址就仅仅是内存空间的一个地址，因为没有指定具体对象的类型，所以无法用 `void*` 指针访问所指向的地址。

```c++
double obj = 3.14, *pd = &obj;
					// 正确： void* 能存放任意类型对象的地址
void *pv = &obj;	// obj 可以是任意类型的对象
pv = pd;			// pv 可以存放任意类型的指针
```

​	**指针为什么要有类型？**

​	既然指针都是4字节，为什么还要有不同类型的指针？原因是指针变量存储的是一个内存空间的首地址，但是这个空间占用了多少字节，用来存储什么类型的数据，地址增量应该加多少，都是由类型决定的。

### 2.3.3  理解复合类型的声明

#### 定义多个变量

```c++
int* p1, p2;    //p1是指向int的指针，p2是int
```

#### 指向指针的指针

​	指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址存放到另一个指针中，可以类推。

#### 指向指针的引用

​	引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```c++
int i = 42;
int *p;			//p是int型的指针
int *&r = p;	//r是一个对指针p的引用

r = &i;			//r是一个指针引用，因此给r赋值&i就是令p指向i
*r = 0;			//解引用r,就是解引用指针p,将p指向的变量i的值改为0
```

面对一条比较复杂的指针或引用的声明语句时，从右向左读有助于弄清楚它的真实含义。



## 2.4  const限定符

​	当我们希望定义一种其值不能改变的变量时，可以用关键字const对变量类型加以限定：

```c++
const int bufSize = 512;
```

​	因为const对象一旦创建后其值就不能改变，所以const对象必须初始化。



**默认状态下，const对象仅在文件内有效**

> ​	*当以编译时初始化的方式定义一个const对象时，编译器将在编译过程中把用到该变量的地方都替换成对应的值。为了执行该替换，编译器必须知道变量的初值。如果程序包含多个文件，则每个用了const对象的文件都必须能访问它的初始值才行，要做到这一点，**就必须在每一个用到变量的文件中都有对它的定义。***
>
> ​	***为了支持这一用法，同时避免对同一变量的重复定义，**默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。*

​	在编译得到的.o文件中，定义一个const变量时，默认生成的变量的符号为local属性，使用extern关键字，为global属性。

​	**解决的办法就是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了**



### 2.4.1  const的引用

​	把引用绑定到const对象上，称为对const的引用（reference to const），可以简称为 “常量引用”但这一概念并不存在。

#### 初始化和对const的引用

​	初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果转换成引用的类型即可。

​	**为什么会有这种例外？**

​	当一个常量引用被绑定到另一种类型时，发生了如下的事情：

```c++
double pi = 3.14;  
const int *ri = pi;
```

​	此处ri引用了一个int型的数。对`ri`的操作应该是整数运算，但`pi`却是一个双精度浮点数，因此编译器为了确保`ri`绑定了一个整数，做了一下改变：

```c++
const int temp = pi;         // 由双精度浮点数生成一个临时的整型常量
const int &ri = temp;        // 让ri绑定这个临时量
```

​	这种情况下，`ri`绑定了一个临时量对象。这种情况在const是可以的，但当 `ri`不是常量时，修改 `ri`修改的其实是 `temp`的值，而并非 `pi`

### 2.4.2  指针和const

​	指向常量的指针（pointer to const）不能用于改变其所指对象的值。

```c++
const double pi = 3.14;       // pi是一个常量，它的值不能改变
double *ptr = &pi;            // 错误：ptr是一个普通指针
const double *cptr = &pi;     // 正确：cptr可以指向一个双精度常量
*cptr = 42;                   // 错误：不能给*cptr赋值
```

​	指针同样存在一种特殊情况，一个指向常量的指针可以指向一个非常量对象：

```c++
double dval = 3.14;
cptr = &dval;
```

​	和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

#### const指针

​	指针是对象，允许把指针本身定位常量。常量指针（const pointer）必须初始化，初始化完成，它的值（也就是存放在指针中的那个地址）就不能在改变了。

​	把 * 放在const关键字之前用以说明指针是一个常量，这样写隐含着一层意味，不变的是指针本身而非指向的那个值：

```c++
int errNumb = 0;
int *const curErr = &errNumb;	//curErr将一直指向errNumb,不可以改变指向
const double pi = 3.14;
const double *const pip = &pi;		//pip是一个指向常量对象的常量指针
```

从右向左读，判断是哪种指针

### 2.4.3  顶层const

**顶层const** : 表示该变量（对象）本身是常量，不可以改变

**底层const**: 表示指向的变量（对象）是一个常量

​	底层const的限制不能忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。

### 2.4.4  constexpr和常量表达式

​	常量表达式（const expression）是指不会改变并且在编译过程就能得到计算结果的表达式。

#### constexpr变量

​	C++11新标准规定，允许将变量声明为 `constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。必须用常量表达式初始化。	

#### 指针和constexpr

```c++
const int *p1 = nullptr;
constexpr int *p2 = nullptr;
int *const p3 = nullptr;
```

p1与p2的类型相差甚远，p1是指向常量的指针，p2是一个常量指针。p2 和p3是等价的，`constexpr`修饰指针变量是被定义为顶层const



## 2.5  处理类型

### 2.5.1  处理类型

#### typedef

​	传统的方法是使用typedef关键字定义类型别名

```c++
typedef double wages;		//wages表示是double类型
typedef wages base, *p;		//base = wages = double, p = double*
//数组的别名
typedef int arrT[10];		//arrT是一个类型别名，他表示的类型是含有10个整数的数组
using arrT = int[10];		//和上面的等价
```

#### using

​	C++11提供了一种新的方法

```c++
using SI = Sales_item;		//Sales_item是一个类类型， SI表示是该类的别名
```

#### **指针、常量和类型别名**

​	如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

```c++
typedef char* pstring;
const pstring cstr = 0;		// cstr是指向char的常量指针
const pstring *ps;			// ps是一个指针，它的对象是指向char的常量指针
```

> *“上述两条声明语句的基本数据类型都是const pstring，和过去一样，**const是对给定类型的修饰**。pstring 实际上是指向 char 的指针，因此，const pstring 就是指向 char 的常量指针，而非指向常量字符的指针。*
>
> ​	*遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：*
>
> ```c++
> const char *cstr = 0;      // 错误，这么理解是一个指向常量的指针
> ```
>
> ​	*再强调一遍：这种理解是错误的。**声明语句中用到pstring时，其基本数据类型是指针**。可是用`char*`重写了声明语句后，数据类型就变成了 char，`*`成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向 char 的常量指针，改写后的形式则声明了一个指向 const char 的指针。”*

​	有两种方法去解释：	

​	① const可以放在类型前或类型后：

```C++
pstring const cstr = 0;
const pstring cstr = 0;
```

​	这两种写法等价，于是可以更直观的看出 `char * const cstr`是一个常量指针。但这种解释更像是被动接受，而并非理解。

​	②明确一个概念，即第一句加粗的话：“const 是对给定类型的修饰” 知道了const是用来限定**类型**的，那么只要看const限定的谁就行了。

​	在原声明语句 `const pstring cstr = 0` 中，`pstring` 的数据类型是指针，const限定指针，即常量指针。第二局加粗后一句重写声明语句，数据类型变成了 char ，指的是替换后的句子，那肯定是一个指向常量的指针。分清楚这段话代词指代的哪些语句就好理解了。

### 2.5.2  auto类型说明符

​	C++11  `auto` 类型说明符可以让编译器分析表达式所属的类型。

```c++
int val1 = 1, val2 = 3;
auto val = val1 + val2;		//编译器可以自动推出val为int类型
auto i = 0, *p = &i;		//正确，编译器通过字面值推出i为int,p为int*
auto sz = 0; pi = 3.14;		//错误，编译器无法推出类型， sz， pi类型不一致无法统一
```

#### 复合类型、常量和auto

-  当使用引用类型推导类型是，`auto`推导的类型是引用指向变量的实际类型 

```C++
int i = 0; &r = i;
auto a = r;		// r是int型的引用,因此a是int型
```

-  `auto`会忽略掉顶层const, 同时底层const则会保留下来 

```c++
const int ci = i, &cr = ci;
auto b = ci;	//int b = ci;
auto c = cr;	//int c = cr;  cr是ci的别名，ci本身是一个顶层const
auto d = &i;	//int *d = &i;
auto e = &ci;	//const int *e = &ci; 对常量对象取地址是一种底层const
```

如果希望推断出的auto类型是一个顶层const，需要明确指出：

```c++
const auto f = ci;    // ci的推演类型是int，f是const int
```

- 还可以将引用的类型设为 `auto`

### 2.5.3  decltype类型指示符

C++11  `decltype` 可以不执行表达式，编译器自动推断出表达式的返回值类型

```cpp
decltype(f()) sum = x;		//sum的类型和f()的返回类型一样
```

通过 `f()` 推断出返回类型，但是并不会执行 `f()`

#### decltype 和const

`decltype`处理顶层 const和引用的方式和auto有点不同，如果 decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0;		//const int x = 0
decltype(cj) y = 0;		//const int &y = 0;
decltype(cj) z;			//错误， const int &z;  引用必须初始化
```

#### decltype 和引用

​	如果decltype 使用的表达式不是一个变量，则decltype 返回表达式结果对应的类型。有些表达式返回一个引用类型

```cpp
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;		// 正确：加法的结果是int，因此b是一个int;
decltype(*p) c;			// 错误： c是int&  引用需要初始化
```

`r` 是引用  `decltype(r)` 是引用，但是 `r + 0` 是一个int型数据

解引用指针得到的是指针所指的对象，，因此 `decltype(*p)` 是 `int&`

变量加上 `()` 得到的是引用类型

```cpp
decltype((i)) d;   	//错误， int& d; 引用类型需要初始化
decltype(i) e;		// int e;
```

 `decltype((variable))`的结果永远是引用