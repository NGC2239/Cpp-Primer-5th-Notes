# 第三章 字符串、向量和数组



## 3.1  命名空间的using声明

### 头文件不应包含using声明

​	位于头文件的代码，一般来说不应该使用using声明。每个使用了该头文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。



## 3.2  标准库类型string

### 3.2.1  定义和初始化string对象

![](https://s3.bmp.ovh/imgs/2022/11/08/fcb14f545bb1b4dc.png)

#### 直接初始化和拷贝初始化

​	如果使用（=）初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。

### 3.2.2  string对象上的操作

![](https://s3.bmp.ovh/imgs/2022/11/08/266ea46ef566448a.png)

#### 读写string对象

​	读：会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白。

​	**使用 getline 读取一整行**

有时我们会希望能在最终得到的字符串中保留输入时的空白符，getline 会直到遇到**换行符**为止（注意换行符也被读进来了），然后把所读的内容存入到string对象中去（不存换行符）。

#### string 的empty和size操作

​	size 函数返回string对象的长度（字符的个数），但返回值并不是int或unsigned。而是`string::size_type` 类型。这是一个无符号类型的值，在类 string 中定义。

​	**注意**：假设n是一个具有负值的int，则表达式 `s.size() < n` 的判断结果几乎肯定是true。

#### 比较string对象

1. ​	如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string小于较长string对象。
2. ​    如果两个string对象在某些对应位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

```c++
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya"
```

​	对象str 小于对象phrase ；对象slang 既大于str 也大于 phrase。

### 3.2.3  处理string对象中的字符

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fkinvy-images.oss-cn-beijing.aliyuncs.com%2FImages%2Fimage-20211216191219702.png&sign=e11f025bfabb17cb5f4bf8ba91f26c06f30cc92a35fc9e68d6f5a52c66a7ef1d)

#### 处理每个字符

​	C++11提供的一种语句：**范围for（range for）**语句。可以遍历给定序列中的每个元素，并对每个值执行某种操作

```C++
for (declaration : expression)
    statement
```

​	其中，expression 部分是一个对象，用于表示一个序列。declaration 部分负责定义一个变量，该变量被用于访问序列中的元素，每次迭代，declaration 部分的变量会被初始化为expression 部分的下一个元素值。

#### 处理一部分字符

​	下标运算符（[ ]）接收的输入参数是 `string::size_type` 类型的值，返回值是该位置上字符的引用。



## 3.3  标准库类型vector

​	标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。因为vector “容纳着” 其他对象，所以也常被称为容器（container）

​	vector 是一个**类模板** （class template），模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型：

​	**在模板名字后面跟一对尖括号，在括号内放上信息**

```c++
vector<int> ivec;		//ivec时int类型的对象集合
vector<vector<string>> file;	//该向量的元素是vector对象
```

**注意：** 在C++11之前，应写成 `vector<vector<string> > ` 右侧尖括号间有一个空格，新标准下不需要，但要注意一些编译器可能仍需要老式的声明语句。

### 3.3.1  定义和初始化vector对象

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fkinvy-images.oss-cn-beijing.aliyuncs.com%2FImages%2Fimage-20211216194615980.png&sign=f3b279abd27cd73c06967db98101cd370a2bb20f9dbd68678aa41e5de25d1c57)

- 如果用的是圆括号，可以说提供的值是用来构造（construct）vector对象的。
- 如果用的是花括号，可以表述成我们想列表初始化该vector对象。但当初始化时用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象。

```c++
vector<string> v5{"hi"};
vector<string> v6("hi");
vector<string> v7{10};             // v7 有10个默认初始化的元素
vector<string> v8{10, "hi"};       // v8 有10个值为"hi"的元素
```

### 3.3.2  vector操作

#### 向vector对象中添加元素

​	**push_back() **向其中添加元素。

**注意**：vector对象能高效增长，除了所有元素的值都一样时，更有效的方法是先定义一个空的vector 对象，再在运行时向其中添加具体值。但一定要确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。

​	范围for 语句体内不应改变其所遍历序列的大小。

### 其他操作

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fkinvy-images.oss-cn-beijing.aliyuncs.com%2FImages%2Fimage-20211216195244036.png&sign=b31ec8e0ac0133026932d5b00ba500be4cb8f04bbaa1145879961743bb1e6ef5)

多数操作与string类似，比较时只有当元素的值可比较时，vector 对象才能被比较。

**不能用下标形式添加元素**

vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。

## 3.4迭代器介绍

​	**迭代器 iterator** 所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。

​	迭代器有有效和无效之分，有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1  使用迭代器

​	有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有 **begin** 和 **end** 的成员，其中 begin 成员负责返回指向第一个元素的迭代器。

end 成员则负责返回指向容器（或string 对象） ”尾元素的下一位置（one past the end）“ 的迭代器，该迭代器指示的是一个本不存在的尾后元素。end成员返回的迭代器常被称为 **尾后迭代器（off-the-end iterator）**或简称 尾迭代器。

​	如果容器为空，则begin 和 end 返回的是同一个迭代器，都是尾后迭代器。

#### 迭代器运算符

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fkinvy-images.oss-cn-beijing.aliyuncs.com%2FImages%2Fimage-20211217154623555.png&sign=8480411b4f6e1bdc38779bd4700367561f420b2c100bcaa2001eac87d1fb8b4d)

​	和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。

#### 迭代器类型

​	拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型

#### begin和end运算符

​	begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量，begin 和 end 返回const_iterator; 如果对象不是常量，返回iterator 。

​	但有时候这种默认行为并非我们所要。C++11新标准引入了两个新函数，分别是 cbegin 和 cend ，无论对象本身是否是常量，返回都是const

#### 结合解引用和成员访问操作

​	**箭头运算符（->）** 

​	it -> mem 和 (* it).mem 表达的意思相同

#### 某些操作会使迭代器失效

### 3.4.2  迭代器运算

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fkinvy-images.oss-cn-beijing.aliyuncs.com%2FImages%2Fimage-20211217160907463.png&sign=177b62733556474e04144bdc527df5050460e153ad77e9e2da8d02e27d65a99e)



## 3.5  数组

### 3.5.1  定义和初始化内置数组

​	数组是一种复合类型。声明形如 a[d]，其中 a 是数组的名字，d是数组的维度（说明了数组中元素的个数）。

> "组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。"

​	但是，C语言自C99开始，在特定条件下允许使用变量作为数组长度定义数组。C++则不允许。于是，在 `g++` 编译器下，下面的写法不会出错，但其实C++是不允许的。

```c++
int n = 5;
int arr[n];        // 错误： n不是常量表达式
```

​	定义数组的时候必须指定数组的类型，不允许用 `auto` 关键字由初始值的列表推断类型。另外和 vector 一样，数组的元素应为对象，因此不存在引用的数组。

#### 字符数组的特殊性

```c++
char a1[] = {'C', 'P', 'P'};		//没有空字符
char a2[] = {'C', 'P', 'P', '\0'};	//手动添加空字符
char a3[] = "CPP";					//自动添加空字符
const char a4[3] = "CPP";			//错误，没有空间可存放空字符
```

#### 不允许拷贝和赋值

```c++
int a[] = {0, 1, 2};
int a2[] = a;    // 错误：不允许使用一个数组的初始化另一个数组
a2 = a;          // 错误：不能把一个数组直接赋值给另一个数组
```

**waning**：一些编译器支持数组的赋值，这就是所谓的编译器扩展。

#### 复杂数组的声明

```c++
int *ptrs[10];				//可存放10个 int* 类型
int &refs[10] = /* ? */ ;	//错误，不存在引用的数组
int (*Parray)[10] = &arr;	//Parray是一个指向 int[10] 类型的指针 
int (&arrRef)[10] = arr;	//arrRef是一个 int[10]类型的引用
int *(&arry)[10] = ptrs;	//arry是一个引用，指向的是 含有10个int*的数组
```

此时，由内向外读，更容易理解所代表的类型

### 3.5.2  访问数组的元素

**warning：** 对于数组的访问，需要注意下标越界的问题。大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。

### 3.5.3  指针和数组

​	数组名就是指针，保存的是数组变量的首地址。

​	由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层是：当使用数组作为一个 `auto` 变量的初始值时，推断得到的类型是指针而非数组。

​	但需要指出的是，当使用 `decltype` 关键字时，上述转换不会发生，返回的类型是数组。

#### 指针也是迭代器

​	**指针为什么是迭代器？**

​	迭代器实际上是对”遍历容器“这一操作进行了封装。

> ”就像使用迭代器遍历 vector 对象中的元素一样，使用指针也能遍历数组中的元素。“

​	指针应有迭代器具有的功能，所以指针也可以算是迭代器的一种。但是指针还有其他功能，并不局限于遍历数组。而迭代器是类模板，表现的像指针，模拟了指针的一些功能，之所以这么做，因为使用指针变量数组的操作深入人心,C++ stl中的迭代器是仿照指针来设计接口的。

#### 标准库函数 begin 和 end

​	C++11 新标准引入了两个名为 `begin` 和 `end` 的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数，使用时，应将数组作为它们的参数。

```c++
int ai[] = {0, 1, 2, 3, 4, 5, 6, 7};
int *beg = begin(ia);	//指向ia首元素的指针
int *last = end(ia);	//指向ia尾元素的下一个位置的指针
```

#### 指针运算

​	和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素：

```c++
auto n = end(arr) - begin(arr);  // n的值是arr中元素的数量
```

​	两个指针相减的结果的类型是一种名为 ptrdiff_t 的标准库类型，一种带符号类型。

#### 下标和指针

​	只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算

```C++
int *p = &ia[2];     // p指向索引为2的元素
int j = p[1];		 // p[1] 等价于 *(p + 1), 就是ia[3]表示的那个元素
int k = p[-2];		 // p[-2] 是 ia[0]表示的那个元素
```

所以内置的下标运算符并不是无符号类型，这点与标准库类型 string 和 vector 不同。

### 3.5.4  C风格字符串

​	在c语言中通常是 `const char*` 表示字符串，并且以空字符 `'\0'` 为结尾。

​	以下是C语言标准库提供的一组函数，这些函数可以操作 C风格字符串，它们定义在 cstring 头文件中，是C语言头文件string.h 的C++版本。

![](https://s3.bmp.ovh/imgs/2022/11/08/b45d3526c37e66b0.png)

​	传入此类函数的指针必须指向以空字符作为结束的数组：

```C++
char ca[] = {'C', '+', '+'};    // 没有以空字符结束
cout << strlen(ca) << endl;     // 错误：ca 没有以空字符结束
```

### 3.5.5  与旧代码的接口

​	允许使用字符串字面值来初始化 string 对象，更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

- 允许使用以空字符结束的字符数组来初始化string 对象或为string 对象赋值
- 在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

​	上述性质反过来并不成立，不能用string对象直接初始化指向字符的指针，为了完成此功能，string专门提供了一个名为 c_str 的成员函数：

```c++
char *str = s;          // 错误：不能用string对象初始化char*
const char *str = s.c_str();    // 正确
```

​	c_str 函数的返回值是一个指针，指向一个以空字符结束的字符数组，但我们无法保证 c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。

#### 使用数组初始化 vector对象

​	不允许使用vector 对象初始化数组，相反的，允许使用数组来初始化vector对象。要实现这一目的，只需要指明拷贝区域的首元素地址和尾后地址就可以了：

```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));
```



## 3.6 多维数组

​	**严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。**

### 指针和多维数组

​	当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

​	因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：

```c++
int ia[3][4];       // 大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia;   // p指向含有4个整数的数组
p = &ia[2];         // p指向ia的尾元素
```







